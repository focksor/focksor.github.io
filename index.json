[{"categories":[],"content":"概述 本文主要讨论 Python 应用如何在 import 一个模块之后 de-import/un-import 此模块。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:1:0","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"背景 在使用 Python 的过程中，我们很多时候需要 import 一个库来帮助自己完成一些代码逻辑。 然而，import 一个库意味着会引入额外的内存使用，而在一些内存受限的环境（如嵌入式设备上），内存是很珍贵的，如果只是为了一个使用频次很低的功能引入一个库会多少显得有些奢侈。 因此，Python 应用如何在 import 一个库并使用完成后 “de-import” ，在某些时候显得尤为重要。 笔者查阅了互联网上的一些资料，均未能达到释放内存的效果，因此写下了这篇文档。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:2:0","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"How To ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:0","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"判断规则 判断一个库是否已释放的最重要标准是引入库前和释放库后的内存用量相差不大，这样才能起到释放内存的作用。如果只是代码中无法使用库及相关接口，但是内存还是贮留在系统中，那意义就不大了。 综上，判断一个库是否已经被释放的步骤如下： 记录此时 Python 应用内存用量为 A 引入一个库 使用该库进行一些操作 释放该库 记录此时 Python 应用内存用量为 B 如果 B 与 A 相差不大，则认为该库已完成释放 为了方便描述，我们在下文中均以导入 asyncio 模块为例（因为它足够大，且不用额外安装）。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:1","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"使用 del 释放 我们知道，已导入的库会索引于 sys.modules 中，所以是不是可以直接删除索引中这个库就可以了呢？ 在 How to de-import a Python module? - Stack Overflow 这篇帖子中，有人就是这样问的，让我们试一下： # file: de_import_with_del.py import gc import sys with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) del asyncio del sys.modules['asyncio'] gc.collect() with open('/proc/self/status') as f: print('de-imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) 执行结果如下： $ python de_import_with_del.py init VmRSS: 9856 kB imported VmRSS: 20092 kB de-imported VmRSS: 20092 kB 可以看到，这样并不能真正释放已导入模块的内存。 不过，这篇帖子下面还贴了另一个邮件[Tutor] How to un-import modules?，上面提到有一种更进阶的方式进行模块释放，其原理是不仅解除了对模块的引用，还解除了其子模块的使用。 这听起来好像很有道理，让我们再试试： # file: de_import_deep_del.py import gc def delete_module(modname, paranoid=None): from sys import modules try: thismod = modules[modname] except KeyError: raise ValueError(modname) these_symbols = dir(thismod) if paranoid: try: paranoid[:] # sequence support except: # noqa: E722 raise ValueError('must supply a finite list for paranoid') else: these_symbols = paranoid[:] del modules[modname] for mod in modules.values(): try: delattr(mod, modname) except AttributeError: pass if paranoid: for symbol in these_symbols: if symbol[:2] == '__': # ignore special symbols continue try: delattr(mod, symbol) except AttributeError: pass with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio # noqa: E402 with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) del asyncio delete_module('asyncio') gc.collect() with open('/proc/self/status') as f: print('de-imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) 执行结果如下： $ python de_import_deep_del.py init VmRSS: 9984 kB imported VmRSS: 20352 kB de-imported VmRSS: 20352 kB 很可惜，还是不行。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:2","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"使用 deimport 库 probml/deimport 库宣称可以释放已导入的库，让我们试试： # file: demo_of_using_deimport.py import gc from deimport.deimport import deimport with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) deimport(asyncio) gc.collect() with open('/proc/self/status') as f: print('de-imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) 执行结果如下： $ python demo_of_using_deimport.py init VmRSS: 15340 kB imported VmRSS: 24044 kB de-imported VmRSS: 24044 kB 很可惜，还是不行。从其源码可以看到，它相比上面我们介绍的 del 方法无非是多删除了 globals() 内的引用。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:3","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"另辟蹊径 回过头来想一下，从运行时中删除一个已导入模块的难点在哪？笔者觉得主要有两点： 导入模块产生了很多变量和字节码，这些对象可能在很多地方都有引用 一般来说，导入一个稍微大点的模块就会不可避免地导入该模块的依赖模块。这会导致我们在导入一个模块的时候实际上导入了多个模块，而我们有不可能去一一识别然后删除 问题 1 倒是还有解决的余地——我们只需要查看 gc 中的相关引用情况，然后一一删除就好。而问题 2 就比较棘手了，我们很难在导入一个模块时去一一分析其依赖模块的导入，依赖模块是否被别的模块依赖……等等。 让我们把思路放宽一下，另辟蹊径地想一下：什么一定要删除模块呢，不引入不就好了？我们知道一个进程 fork 出来的子进程会继承主进程的资源，而子进程结束并不会影响主进程的运行。那是不是可以先创建一个子进程，然后在这个子进程中完成脏活累活，最后销毁该子进程——这样是不是主进程并不用导入模块，而又利用该模块完成了预定任务？让我们试试。 使用 fork+pipe 代码如下： import os import pickle def run_in_other_process(func, *args, **kwargs): \"\"\" Run a function in another process using os.fork and os.pipe. \"\"\" read_fd, write_fd = os.pipe() pid = os.fork() if pid == 0: # Child process os.close(read_fd) try: result = func(*args, **kwargs) with os.fdopen(write_fd, 'wb') as wf: wf.write(pickle.dumps(result)) except Exception as e: with os.fdopen(write_fd, 'wb') as wf: wf.write(pickle.dumps(e)) os._exit(0) else: # Parent process os.close(write_fd) with os.fdopen(read_fd, 'rb') as rf: result = pickle.loads(rf.read()) if isinstance(result, Exception): raise result return result def a_task_using_asyncio(a): with open('/proc/self/status') as f: print('task init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio # noqa: F401 with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) return a ** a with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) assert run_in_other_process(a_task_using_asyncio, 3) == 27 with open('/proc/self/status') as f: print('task done', ''.join(line for line in f if line.startswith('VmRSS')).strip()) 运行结果： $ python demo_of_using_fork+pipe.py init VmRSS: 17120 kB task init VmRSS: 11896 kB imported VmRSS: 21624 kB task done VmRSS: 17248 kB 使用 fork+socketpair 代码如下： import os import pickle import socket def run_in_other_process(func, *args, **kwargs): \"\"\" Run a function in another process using os.fork and socket.socketpair. \"\"\" parent_sock, child_sock = socket.socketpair() pid = os.fork() if pid == 0: # Child process parent_sock.close() try: result = func(*args, **kwargs) child_sock.sendall(pickle.dumps(result)) except Exception as e: child_sock.sendall(pickle.dumps(e)) finally: child_sock.close() os._exit(0) else: # Parent process child_sock.close() result = pickle.loads(parent_sock.recv(4096)) parent_sock.close() if isinstance(result, Exception): raise result return result def a_task_using_asyncio(a): with open('/proc/self/status') as f: print('task init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio # noqa: F401 with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) return a ** a with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) assert run_in_other_process(a_task_using_asyncio, 3) == 27 with open('/proc/self/status') as f: print('task done', ''.join(line for line in f if line.startswith('VmRSS')).strip()) 运行结果： $ python demo_of_using_fork+socketpair.py init VmRSS: 17492 kB task init VmRSS: 12204 kB imported VmRSS: 21676 kB task done VmRSS: 17620 kB 使用 multiprocessing 代码如下： import multiprocessing def run_in_other_process(func, *args, **kwargs): \"\"\" Run a function in another process. \"\"\" with multiprocessing.Pool(1) as pool: result = pool.apply(func, args, kwargs) return result def a_task_using_asyncio(a): with open('/proc/self/status') as f: print('task init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) import asyncio # noqa: F401 with open('/proc/self/status') as f: print('imported', ''.join(line for line in f if line.startswith('VmRSS')).strip()) return a ** a with open('/proc/self/status') as f: print('init', ''.join(line for line in f if line.startswith('VmRSS')).strip()) assert run_in_other_process(a_task_using_asyncio, 3) == 27 with open('/proc/self/status') as f: print('task done', ''.join(line for line ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:4","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"总结 从上个章节，我们可以看到各个方法主进程在执行任务的前后内存用量变化非常少（应该是启动子进程以及进程间通信带来的开销），而主要的内存用量都体现在子进程上了——由于子进程在执行完任务之后会释放，所以完全没有关系。 当然，你可能注意到使用有些方法初始化的内存会比较大，这是因为导入用于创建子进程以及进行进程间通信的库也会消耗相当量的内存。你可以根据自己项目中导入了哪些库、任务传递数据的格式和实际的工程情况，决定你使用什么方法实现 run_in_other_process 中关于子进程启动和进程间通信的部分。 ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:3:5","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":[],"content":"资源 本文档所有相关文件和脚本均已上传到 Github How to de-import a Python module? - Stack Overflow [Tutor] How to un-import modules? ","date":"2025-06-13","objectID":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/:4:0","tags":["Programming"],"title":"Python 删除已导入的模块","uri":"/posts/python-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"概况 本文档描述了使用 django 创建 web 项目，并通过 uWSGI 启动的方法和过程。 ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:1:0","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"启动前准备 ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:2:0","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"准备软件 本文档中涉及的软件有 uwsgi 和 django，均可以通过 pip 安装： pip install uwsgi pip install django ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:2:1","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"准备网站 下面我们通过 django-admin 创建一个最简单的应项目： django-admin startproject mysite 创建好的 django 项目在 mysite 路径下。 ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:2:2","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"使用 uWSGI 启动应用 使用 uWSGI 启动创建好的 django 项目： uwsgi --http :8000 --module mysite.wsgi --chdir mysite --pidfile uwsgi.pid --daemonize uwsgi.log --vacuum 参数说明： 参数 说明 –http :8000 在 8000 端口启动 HTTP 服务器 –module mysite.wsgi 启动的应用 –chdir mysite 应用的路径 –pidfile uwsgi.pid 启动后留下 pid 文件 –daemonize uwsgi.log 启动后在后台运行，日志输出到 uwsgi.log –vacuum 进程结束时自动删除 pid 文件等临时文件 ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:0","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"验证 启动后，可以使用浏览器访问 http://localhost:8000 ，可以看到 django 的欢迎页面。 除此之外，也可以使用 curl 命令访问网站： focksor@focksor:~/workSpace/uwsgi_django_demo$ curl -s http://localhost:8000/ | grep \"The install worked successfully! Congratulations!\" \u003ctitle\u003eThe install worked successfully! Congratulations!\u003c/title\u003e \u003ch1\u003eThe install worked successfully! Congratulations!\u003c/h1\u003e focksor@focksor:~/workSpace/uwsgi_django_demo$ ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:1","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"终止 在上面我们使用后台运行的方式运行 uwsgi，并留下了 pid 文件。故我们只需要 cat 这个 pid 文件并 kill 掉对应进程就好： kill `cat uwsgi.pid` ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:2","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"资源 编写你的第一个 Django 应用，第 1 部分 | Django documentation | Django 如何用 uWSGI 托管 Django | Django documentation | Django 本文相关脚本已上传到 Github：focksor/uwsgi_django_demo ","date":"2025-06-03","objectID":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:4:0","tags":null,"title":"uWSGI+Django 最简实践","uri":"/posts/uwsgi+django-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"概况 uWSGI 提供了一个 cgi 插件，可以让你通过 uWSGI 来运行传统的 CGI 脚本（虽然现在一般不会有人这样做）。 ⚠️ 注意事项 uWSGI 的 CGI 插件性能一般，并不适合高并发或生产环境，只适合兼容旧系统或做一些调试。 它只是提供了一个兼容层，内部仍是 fork+exec 来执行 CGI 脚本，性能开销与传统 CGI 接近。 uWSGI 更多的是用于运行 WSGI 应用，如 Flask、Django，而不是传统 CGI。 ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:1:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"安装 uWSGI ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:2:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"编译安装 uWSGI+CGI plugin uWSGI 默认不支持 CGI 应用。要支持 CGI，则需要安装其 CGI plugin。通过以下命令编译 uWSGI 及其 CGI 补丁： git clone git@github.com:unbit/uwsgi.git -b uwsgi-2.0 --depth=1 cd uwsgi make PROFILE=cgi python uwsgiconfig.py --plugin plugins/cgi 编译完成后，通过以下命令验证 uWSGI 的可用性： $ ls ./cgi_plugin.so ./cgi_plugin.so $ ./uwsgi --plugin cgi --plugins-list 2\u003e\u00261 | grep cgi 9: cgi 如上所示，uWSGI 以及其 cgi 插件已经就绪。 ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:2:1","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"编写 CGI 应用 CGI 应用说白了就是一个可执行的程序，启动后能够输出 HTTP 响应内容就好了。下面是使用 C 和 BASH 实现的 CGI 应用。 ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"使用 C 创建 CGI 应用 创建 hello.c： #include \u003cstdio.h\u003e int main(void) { printf(\"Content-type: text/plain\\n\\n\"); printf(\"Hello, CGI world!\\n\"); return 0; } 将其编译为 cgi 应用，编译后尝试执行，可以输出内容： $ gcc hello.c -o apps/hello.cgi $ ./apps/hello.cgi Content-type: text/plain Hello, CGI world! ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:1","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"使用 Bash 创建 CGI 应用 编写 bash.cgi #!/bin/bash echo \"Content-Type: text/plain\" echo \"\" echo \"Hello, CGI Bash Script!\" 创建后给它赋予执行权限，并尝试执行，可以输出内容： $ chmod +x apps/bash.cgi $ ./apps/bash.cgi Content-Type: text/plain Hello, CGI Bash Script! ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:3:2","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"启动 uWSGI 通过以下命令启动 uWSGI 应用： ./uwsgi --plugin cgi --cgi ../uwsgi_simple_app/apps/ --http-socket :9000 --http-socket-modifier1 9 参数说明： 参数 说明 –plugin cgi 加载 cgi plugin –cgi ../uwsgi_simple_app/apps/ 指定 cgi 应用所在的路径 –http-socket :9000 使用 HTTP 协议，绑定到 9000 端口 –http-socket-modifier1 9 使用 CGI 补丁处理 HTTP 协议的请求。其中 9 是 CGI 的标识，可以用如下命令看到：./uwsgi --plugin cgi --plugins-list 2\u003e\u00261 | grep cgi ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:4:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"验证访问 uWSGI 启动后，可以通过 curl 或浏览器访问相应的 url 以访问应用。下面以 curl 为例： $ curl http://localhost:9000/hello.cgi Hello, CGI world! $ curl http://localhost:9000/bash.cgi Hello, CGI Bash Script! ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:4:1","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"易踩坑问题 未加载应用 如果启动日志中输出以下内容： *** no app loaded. GAME OVER *** 这是因为 CGI 应用是动态加载的，所以会显示没有加载应用，上面的日志是正常的。 但是如果启动日志中输出以下内容 *** no app loaded. GAME OVER *** 则需要在启动参数中加入 --need-app=false (或删除 --need-app=true，如果你加了的话)。 ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:5:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"未找到标识符 0 出现该问题时，启动日志中输出以下内容： -- unavailable modifier requested: 0 -- 且 curl 或浏览器无法访问 uwsgi 绑定的服务器地址。这是因为 uwsgi 默认是以 Python 插件（标识符为 0）处理的，如果你的 uWSGI 并没有编译这个插件，则会报这个错误。 解决方法： 在我们的应用场景中（使用 CGI 插件处理 HTTP 请求），是完全不用 Python 插件的。因此，当出现该问题的时候，你只需要在启动命令加上参数 --http-socket-modifier1 9，要求 uWSGI 以 CGI 插件（标识符为 9）处理 http-socket 请求就好了。 如果你不是通过 --http-socket 参数的方式绑定监听地址，则使用 ./uwsgi --help | grep modifier1 查看并找到符合你需求的参数。 但是，如果你确实是想要以 Python 插件启动应用时遇到了这个问题，则是因为你的 uWSGI 并没有集成 Python 插件，使用以下命令重新编译 uWSGI 以解决问题： make clean make PROFILE=default ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:5:1","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"未找到 Python 应用 出现该问题时，启动日志中输出以下内容： --- no python application found, check your startup logs for errors --- 这种情况是因为你的 uWSGI 中已经集成了 Python 插件，当 uWSGI 启动时会默认去查找是否有 Python web 应用（很明显在我们这篇文档所述的环境里是找不到的），因此会提示此错误。 这个问题出现的原因其实跟上个问题是一样的，错误信息仅仅取决于你的 uWSG 是否集成了 Python 插件。要解决这个问题，我们需要添加一个参数来切换默认的处理应用：--http-socket-modifier1 9（同上个问题的解决方法）。 ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:5:2","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"找不到 CGI 插件 出现该问题时，启动日志中输出以下内容： open(\"./cgi_plugin.so\"): No such file or directory [core/utils.c line 3709] !!! UNABLE to load uWSGI plugin: ./cgi_plugin.so: cannot open shared object file: No such file or directory !!! 这是因为你没有编译 CGI 插件。使用以下命令编译插件以解决问题： python uwsgiconfig.py --plugin plugins/cgi ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:5:3","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"资源 上文中所有提及的源码及其验证脚本打包上传到了 Github 上，希望对你有帮助。 uWSGI CGI 官方文档：Running CGI scripts on uWSGI — uWSGI 2.0 documentation ","date":"2025-05-31","objectID":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/:6:0","tags":null,"title":"uWSGI+CGI 最简实践","uri":"/posts/uwsgi+cgi-%E6%9C%80%E7%AE%80%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"Hello World! Here is my first post. ","date":"2025-03-31","objectID":"/posts/hello_world/:0:1","tags":null,"title":"Hello World!","uri":"/posts/hello_world/"}]